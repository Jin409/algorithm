#한 개의 회의실
n = int(input())

"""
그리디 알고리즘
끝나는 시간이 빠른 순으로 배정하는 것이 좋음. 
-> 계속 틀림
-> 구글링 해보니, 회의의 시작시간과 끝나는 시간이 같을 수도 있다.라는 조건에 의해서 문제가 된다고 함.
ex) 
3,3
2,3 이라면 3,3이 선택됨.
그러나 2,3 이 선택되고 3,3이 선택된다면 두개를 진행할 수 있음.
-> 따라서 끝나는 시간으로 정렬하고, 시작하는 시간으로도 정렬을 해야 함. 
"""

arr =[
    tuple(map(int,input().split()))
    for _ in range(n)
]

arr.sort(key=lambda x:x[0]) #시작하는 시간으로 먼저 정렬을 해준 뒤에, 
arr.sort(key=lambda x:x[1]) #끝나는 시간으로 정렬을 해준다.
# -> 이렇게 되면 첫번째 정렬에서 (2,3) (3,3) 이 되고 그 뒤의 정렬에서도 이가 유지된다. 

cnt = 1 #이미 하나를 더했으므로 (아래의 arr[0])
before_s,before_e = arr[0]


for i in range(1,n):
    s2,e2 = arr[i]
    #이전 회의가 끝나는 시간이 이후 회의가 시작하는 시간보다 작거나 같다면
    if before_e <= s2:
        cnt+=1
        before_s,before_e = s2,e2

print(cnt)